# Efficient Detection of Split Personalities in Malware

## 摘要

恶意程序是很多互联网安全威胁的主要原因. 为了对付每天都会发现的成百上千的新恶意软件, 安全公司与研究人员一依靠自动化工具提取恶意软件的行为特征. 与此同时恶意软件作者也想方设法的防止被检测.恶意软件通常也具备检查出虚拟测试环境的能力. 这时恶意软件会改变行为模式或者直接崩溃, 和在正常系统里运行相比, 恶意软件在虚拟测试环境中会表现出不同的行为.

一种透明检测平台(Ether, Cobra)的出现使得恶意软件更难以检测出测试环境, 另一些提出了使用某些技术去识别并通过恶意软件的检测. 两者都成功检测出恶意软件并使恶意软件的防范机制失效. 然而两者都导致了高性能开销, 这使得它们不适合做大批量的恶意软件分析.

这份论文中, 我们将介绍一种技术可以高效检查出恶意软件在测试环境中的异样行为. 原理很简单:　比较在测试环境中与参考机器上的样品行为．　然而一个强大有效的比较实现是有困难的．　我们将记录恶意软件与操作系统的交互并将此作为测试环境中给样品的回复．我们将通过实验演示，通过这个方法，可以有效检测出具有很强防范机制的恶意软件．

## 介绍

与日俱增的恶意软件数目使安全公司与研究人员投入更大的精力用以研发自动化的恶意软件检测工具, 这些工具通常在受限环境中(沙箱)运行未知软件, 监测未知程序的行为. 根据监测到的结果, 研究人员能够评估恶意软件的威胁程度以及制定相应防范策略. 当然恶意软件作者也会编写相应代码以防范被检测出来. 通过隐藏在自动检测系统中, 恶意软件可以运行更长一段时间.

为了阻挠自动侦察, 恶意软件作者开发出了很多方法去检查恶意软件分析工具和沙箱. 当恶意软件发现存在恶意软件分析工具, 通常会不执行恶意功能或是直接退出. 恶意软件依靠恶意软件分析工具的目标类型实现这类检测. 一种检测来自运行环境的输入以确定是否存在分析工具. 通常这类检查查找文件, 注册表, 或是分析工具进程. 第二种检测检查测试环境与真实环境的不同特征. 对于这些检测, CPU指令的细小变化或是定时属性都是恶意软件用来确定运行环境的因素.

要解决"反检测恶意软件", 研究人员探索出两种途径. 一种专注与开发更难以察觉的分析平台, Cobra是最早的透明分析系统之一. 这种系统在检测中执行动态的代码转换, 也就是说每段代码块在执行前被反编译并检查. 在这个过程中, 每条指令都会被Cobra检查并替换为一个安全的版本, 这被称为透明注入(stealth implant). 之后研究人员提出了Ether, 一个利用硬件虚拟化以保持对恶意软件不可见的系统.

Cobra和Ether都展示出了它们难以被现有的恶意软件所发现. 然而, 它们也导致了不可忽视的性能负担, 特别是在执行细粒度(fine-grained)分析时. 不幸的是, 对于Anubis所生产的分析工具以及类似系统, 要得到全面的分析报告, 这样级别的分析是必须的. 这是因为这些系统至少需要检查从额外的Windows API库函数到系统调用的所有参数, 而且在运行时还经常追踪额外的信息. 影响性能的主要原因是Cobra和Ether通过进程执行单个指令. 有趣的是, Ether的作者指出他们的细粒度(fine-grained)分析"不是用来做实时分析的", 于此同时Cobra的作者指出他们工具的表现"在交互分析局限之内." 鉴于这些局限, 这些系统不适合用来自动处理大容量的恶意软件分析. 例如, Anubis每天接受到几千个恶意软件样本, 而这个数字对于商业反恶意软件公司可能更大.

第二类途径是检测恶意软件在不同环境下的行为异常. 最近, 研究人员提出了一个工具, 用以比较恶意软件在正常系统中与虚拟分析环境中的运行情况. 运行结果的偏差被认为是由恶意软件的检查机制导致的. 这个理论中的基本想法是很有吸引力的, 它保证了一种通用的恶意软件检测机制, 即恶意软件在不同运行环境下的行为异常. 然而在实践中还有一些需要解决的问题, 有效的执行异常检测是很重要的, 而且任何异常应该仅仅由恶意软件自己的检测机制所引发. 不幸的是上述的工具难以解决这两个问题. 首先, 这个个工具使用Ether产生参考轨迹, 这导致了难以接受的性能损耗. 其次, 恶意软件样本只简单地执行了两次, 一次在分析环境中一次在参考环境中. 然而正如我们的实验所演示的那样, 即使没有反分析检测, 执行恶意软件样本也会导致不同的运行结果. 因此, 两次执行追踪的不同并不是检测是否为恶意软件的有效指标.

这篇论文中我们提出一种有效可靠的检测工具, 它能够检测在不同环境下行为不同的恶意软件, 即那些"人格分裂"的恶意软件. 为了执行检测, 我们利用基本的一个想法, 在给定相同输入的情况下, 程序在测试环境中与参考环境中的运行结果应一致. 更进一步说, 我们在参考环境里用内核驱动有效记录下那些在分析环境中被恶意软件样本所执行的系统调用(和它们的参数)的轨迹. 这份系统调用日志包含了输出参数(被程序输出和被系统接收的值)和输入参数(由系统提供并被程序接收的值). 下一步在测试环境中再进行一次. 我们的分析环境是修改版的Anubis, 这是一个系统模拟器Qemu的扩展. 根据系统调用日志, 我们可以提供与参考系统相同的输入参数. 这允许我们在给出相同信息的情况下, 检查系统输出(与它们的参数)是否与期望的相符. 由于输入是相同的, 因此我们期望结果的偏差是由恶意软件的检查机制所导致的, 并因此导致了恶意软件执行了不同的流程.

我们的Windows进程回放设备是这个分析环境的核心组件, 它功能全面并支持那些需要特殊处理的功能, 例如多线程, 存储器映射文件, 和延迟系统调用. 这对于处理复杂的Windows内部进程并使系统在面对真正的恶意软件时能够正常工作是必不可少的. 我们的实验结果显示这样该系统能够识别多种不同的反分析检测. 此外, 系统可以成功的执行(回放)不包含检测的程序, 而且能够检测出带有反分析检测的恶意软件.

这篇论文的主要价值如下:

- 我们提出了一种可信有效的方法去检测"人格分裂"的恶意软件. 通过比较分析系统环境下与参考环境下程序运行的系统调用跟踪记录, 我们可以检测出带有反分析能力的恶意软件.
- 我们完善了一种对Windows进程的全面回放设备, 这使得我们在分析环境下与参考环境下能以相同的输入执行程序.
- 我们演示了我们的工具可以检测出带有反分析能力的恶意软件, 甚至是那些能够逃避Anubis的恶意软件.

## 问题说明

自动恶意软件分析工具(如Anubis)的终极目标是尽可能完善对于恶意软件行为的理解能力. 在实践中, 这些恶意软件分析工具通常遵循一个动态的方法, 简单的执行一个未知程序, 监视运行时行为. 两个限制分析工具送回结果完整性的问题是测试范围是有限的而且恶意软件能够检测并逃避测试工具的检测. 为了解决第一个问题, 研究人员提出一种拓展方法, 探索多条执行流程或使用静态分析扫描未执行的代码区域.

为了解决恶意软件能够检测出分析工具的问题, 研究人员提出了难以被察觉的透明分析工具. 如前所诉, 这些工具是有效的并能高效的收集系统调用踪迹. 然而, 对于不仅包括系统调用的细粒度分析, 这些工具不得不依赖于一种对单指令检测记录的模式. 对于当下的恶意软件分析需要来说这太慢了, 难以应付每天上千个的恶意软件样本. 不幸的是, 想要得到完整全面的分析结果, Anubis和其他工具需要查看更多信息, 而不单是系统调用, 因此, 需要细粒度分析. 例如, Anubis检查Windows API库调用并跟踪数据流的依赖.

**透明恶意软件分析.** 一种可以被看作是对于恶意软件不可见的Anubis或其他类似工具的修改版. 为了检验是否奏效, 用不同恶意软件的反检测方法进行实验是很有用的. Ether的作者提出一个透明检测系统必须满足5个基本要求. 这个系统既是本篇论文所提出并由我们完善的技术, 在Anubis的章节中我们会讨论这几个基本要求.  然而这个讨论适用于所有在模拟器或虚拟环境下运行恶意软件的所有方法. 一些替代方法(如CWSandbox或Joebox)将其中一部分运行于恶意软件进程内或是与之运行在一个操作系统之下, 恶意软件于分析工具具有类似的权限级别, 这样的分析平台就不是透明的.

要做到透明首先分析工具必须比程序具有更高权限. 这个要求对于那些在模拟器或虚拟环境中运行目标的方法来说并不重要. 对第二个要求也是如此, 其指出所有由分析器引入的副作用不可被不具备权限的恶意软件操作所访问.

第三个要求规定分析器在不同环境下指令集语义不变. 这个条件很难被模拟器满足. 一个模拟器仅仅是一个复杂硬件设备的软件实现. 因此总是有可能检测出不同的. 先前的工作也确实指出了基于模拟器于真实CPU不同的CPU语义攻击, 这也可以被恶意软件所利用. 这类攻击利用未有记录的X86指令副作用或是找寻具体CPU的模式寄存器, 而这些在模拟器中是不存在的.

第四个要求规定异常处理必须透明. 这同样要求系统调用(包括系统调用的结果)在分析环境与真实环境下必须一致. Ether的作者称Anubis和其他精心设计的基于模拟器的系统能够满足这个条件. 然而在实践中, 有很多种方法检查操作系统环境中的工件以探测是否为模拟器. 包括特定进程, 驱动, 或是游客系统中的注册表值. 例如, 在一个典型的Windows VMware工作站中, 注册表包含超过300条包含字符串VMware的事件. 理论上隐藏这些工件是可行的, 但是实践中却非常困难. 有许多找寻游客系统中资源以确定是模拟器还是分析系统的攻击, 它们也被恶意软件所利用.

第五个要求声明, 对于一个透明恶意软件分析系统, 应当有一个统一的时间度量. 也就是说, 指令在模拟器下与真实环境下的运行时间应当相同. 显然这不可能, 模拟器或虚拟机上执行指令要比原生机器上更慢. 通过让尽可能多的频道通过一个运行计时进程, 计时攻击非常难以缓解. 事实上, 基于外部资源的输入的计时检测并不包含在诸如Ether系统的威胁模型里.

考虑到分析系统的复杂度以及CPU语义的范围, 环境, 以及恶意软件作者所掌握的计时攻击, 要让Anubis对单个检测透明显然是一场艰苦战斗. 同样, Garfinkel等人得出结论, 要让虚拟机与真实机器无法被区分是不切实际的. 因此, 我们设想一种更通用的解决方法. 我们的方法是一个两步处理.

**发觉人格分裂的恶意软件.** 第一步中我们检测是否有人格分裂的恶意软件. 这也是本篇论文所诉工具的关注点. 我们所诉工具在这里的目标是检测那些在分析环境中与参考环境中(不包含分析工具)表现不一致的恶意软件.
注意我们将一个模拟器(例如Anubis所使用的Qemu)看作是分析环境中的一部分. 这样我们的系统也能够识别那些检测Qemu的恶意软件. 程序行为由程序引用的系统调用(类型于参数)定义. 我们认为这是一个合理的假设, 因为系统调用是程序与环境的通讯手段, 它可以引起操作系统或是其他主机(通过网络)的持久性变化.

一个工具能够可靠有效的识别人格分裂的恶意软件是很重要的. 我们努力使系统没有漏报或错报. 漏报更加严重, 这意味着分析人格分裂的恶意软件失败了, 极有可能漏掉了一个严重威胁. 错报通常会导致性能损失, 因为人格分裂的恶意软件导致了额外的分析工作. 出于对性能的考虑, 我们要求探测器不要增加太多额外开销到现有的Anubis分析处理中. 目前, Anubis分析环境在两台物理机器上包含10个Qemu活动. 尽管机器得到了充分利用,  依然不安排它们处理我们每日的样本需求量. 因此, 在少量样本的情况下任何的开销增加都会立即被分析.

**处理人格分裂的恶意软件.** 第二步是利用发觉人格分裂恶意软件过程中收集到的信息改善分析结果. 一个可能性是在透明但是代价高昂的分析框架如Ether中重复运行恶意软件样本. 这种情况下我们所提出的系统作为一个高效可靠的过滤器去检查那些需要额外分析的恶意软件. 目前, 这种方法是实际可行的. 试图检测分析环境的恶意软件所占比例相当低. 例如, 在前面的工作中, 我们发现在Anubis数据库中低于1%的样本执行了已知的探测分析环境的检测或是被可被识别的保护程序(如Armadillo或tElock)打包或者在Qemu中崩溃. 这和一项相关研究的发现是一致的, 这个研究的作者证明约4%的恶意软件在虚拟机下表现出不同的行为. 然而随着比例的升高, 需要一个替代方案. 一个可能的场景是进行额外的分析以识别行为异样的根本原因. 一旦根本原因被发现(可能是恶意软件检测), 分析系统可以适应并自动绕过这样的检测. "emulation-resistant"程序就遵循这样的方法, 其模拟技术正如上述.

## 我们的方法

本节中我们讨论如何判断一个给定的恶意软件是否存在分裂人格. 就如前面所提, 这个方法的基本思路是比较恶意软件在分析环境或参考环境的执行情况. 我们将会看到这对我们的方法来说是有效可靠的, 我们需要扩展这种想法, 用一种机制记录下参考环境下传给恶意软件的输入, 并且在分析环境中重现.

### 有效的检测

论断一:　程序的运行行为可以被它执行的有序系统调用所描述．
我们证明这个论断有个基础，　系统调用提供用户态进程影响其环境或是主机的一种机制．因此，　为了捕捉恶意软件有意隐瞒的动作，我们认为有充分理由去检查其按序执行的系统调用（系统调用及其参数值）．　这与我们先前工作的目标是一致的，　我们认为可以用系统调用来模式化恶意软件行为或是合法进程的漏洞影响．

在论断一的基础上，　比较一个程序在不同环境下的行为归结起来就是检查是否产生了同样的系统调用序列（同样类型和参数值）．　由于这种比较仅要求粗略分析而不是更加精确，但也更加昂贵的独立结构细化分析，　所以这种分析能够更高效的执行．

### 可靠的检测

为了讨论分裂人格的恶意软件检测的可靠性，　我们引入等效执行(execution equivalent)的概念． 对于两个系统, 如果说对所有程序, 始于相同的初始状态, 接收相同的输入表现出相同的运行行为, 我们称之为等效执行(execution equivalent).

对于这个定义, 我们同样假设程序不存在竞争条件. 我们相信这对于大多数程序都是合理的假设. 而且违背这个假设, 恶意软件作者也无法通过检测. 相反, 存在竞争条件的程序可能会被错判为恶意软件.

论断二: 当程序行为在两个等效执行(execution quivalent)的系统中表现出不同行为时, 这种差异是CPU语义或计时攻击的结果.

同样的程序在两个等效执行的系统中表现的不同暗示了对这些程序而言一条(或多条)CPU指令的运行结果产生了对其可见的影响, 这些程序因此执行了不同的流程.这个影响即有可能是两个系统间CPU指令语义的不同所造成也有可能是因为不同的计时特征. 这恰恰是CPU指令和计时攻击的表征.

当然, CPU语义或是计时攻击并非必然导致不同行为. 也就是说, 有可能是恶意软件具有检测分析环境的能力, 但却决定无视检测结果. 然而这个情况中, 通过分析是能够观察到恶意软件二进制码的全部行为的, 因此, 我们不将这样的程序视作人格分裂.

细心的读者可能注意到论断二尤其关注了CPU语义和计时攻击, 但却排除了环境攻击. 原因是当在两个等效执行系统下运行恶意软件环境攻击不能被检测为行为差异. 这是因为环境攻击分析改变了从操作系统中读入的输入值.因为等价执行意味着程序在两个系统下接收相同的值其结果也相同. 然而如我们所见, 我们的系统设计使分析系统对这类攻击是透明的. 因此, 我们的检测只关注检测执行CPU语义和计时攻击的恶意软件. 论断二激发了我们检测方法的设计. 即通过在参考系统与分析系统中运行恶意软件, 任何行为异常都是我们确定人格分裂恶意软件的有力证据. 当然这仅在参考系统和分析系统都是等价执行的情况下.

### 使系统等价执行

论断三: 为了能够通过比较在不同系统下的行为可靠检测出人格分裂的恶意软件, 这两个系统必须是等价执行的.

为了使这两个系统(比如我们的分析系统和参考系统)等价执行, 我们必须保证程序有相同的初始状态和输入. 为了保证相同的起始状态, 分析环境和检测环境我们使用相同的操作系统. 这保证了诸如程序加载器和运行库这样的操作系统组件是相同的. 此外我们禁用了任何的随机化机制以避免在加载时重排了进程的地址空间布局.

要确保传给两个程序的输入相同要更复杂. 即使是相同的系统提供相同的文件系统对象, 运行相同的程序也有可能导致不同行为, 即使它并不是人格分裂的程序. 一个明显的例子是, 程序可以使用远端主机对不同客户端连接产生的不同的返回值. 更难察觉的例子包括了程序使用当前时间和当前处理器负载这样的系统信息. 因此, 不可能简单的将程序的不同执行结果当作是程序人格分裂的可靠指标.

我们的解决方法是提供由参考系统上系统系统调用记录产生的输入, 再在分析系统上重放. 也就是我们在分析系统下以记录模式运行程序. 这种模式中, 所有系统调用及其输入输出都会被记录. 接着, 在分析系统下, 我们以回放模式运行. 这个模式中, 每当程序调用系统调用, 我们截取并从日志中获取相应调用. 接着不是让系统处理调用, 而是我们简单的回放记录下的系统调用, 也就是说, 在依据参考系统记录日志我们设定好对应的返回码与输出参数后将控制权交还给程序. 举例说, 在我们的方法里, 当一个程序试图在回放模式中读取文件, 将不会访问到真正的文件, 而是接收到参考系统记录模式下所读到的文件内容.

重放在参考系统下记录的输入有个重要的优点就是不受环境攻击影响. 就是说当恶意软件试图访问可以暗示目前环境的文件时, 系统只重放参考系统下的资源. 因此, 在分析过程中, 环境攻击将不会影响结果, 分析过程对于这种攻击也是透明的.

遗憾的是不可能简单重放所有恶意软件在分析系统中的调用的系统调用. 事实上, 有很多系统调用重放是不安全的. 比如如果我们重放一个通过简单地返回存储器缓冲器在参考系统上的分配地址来实现分配内存的系统调用的返回值, 那当程序访问这块内存时很可能会崩溃.原因是操作系统还未建立必要的虚拟存储内部映射,然而程序却假定了这块存储被正确的保留了. 其结果是访问导致了页错误.因此, 因此, 重放组件只重放那些从环境读数据的系统调用. 我们所考虑的输入通道包括文件系统, 注册表, 网络和时间计算.这保证那些从环境获取输入值的系统调用在参考系统下能接收到适当的数据.其他用作管理的系统调用(如分配内存, 产生线程等)会被监视但是直接转给底层系统.

### 系统调用匹配

假设我们有个捕获恶意软件在参考系统下行为的系统调用跟踪. 我们在分析系统执行恶意软件. 对于观察到的每条系统调用, 我们检查其类型与输入参数在日志中是否有匹配. 如果有则回放返回值与输出参数. 当观测到的系统调用类型或是参数不同, 我们就确定了与预期行为的偏差, 就可以将这个恶意软件标记为人格分裂.

不幸的是实际中并没有这么简单. 原因是极小的时间差异会导致细微的意外的行为差异. 比如, 在中断传输中一个极小的延时也会导致进程发出额外的系统调用. 更具体说, 考虑WaitForSingleObject函数, 其等待特定对象能够被访问或是超出等待时限. 这样的函数常被用在循环等待访问操作系统对象中, 可能在两个系统下程序执行了更多(或更少)的调用. 另一个例子是信号的传输会导致进程的系统调用发生点在整条执行轨迹上略微不同.

先前概述的偏差导致系统调用轨迹的略微不同. 然而, 这些变化不会导致所关注的真正的恶意软件行为的不同. 就是说这些程序产生的持久变化仍能被观测到. 为了处理这些情况, 我们要稍微放松对等价行为的定义. 更准确说, 我们不要求记录模式与回放模式产生的系统调用序列完全一致, 我们允许一定灵活性包容微小差异. 这种灵活匹配的方法基于我们对一些常因为时间并在程序执行过程中会很快消失的小差异的观察.

在回放模式中实现灵活的系统调用匹配的算法很简单. 我们使用两个队列跟踪执行中发生的短时差异. 一个队列叫buf_extra, 其记录被程序调用但却不在日志中的系统调用. 另一个叫buf_skipped, 保存在日志中但却没有在执行中被调用的系统调用.

在每个系统调用时, 我们的算法将其与日志当前的头进行比较. 如果找到匹配, 算法返回该系统调用并进下一步. 反之, 算法首先搜索先前在系统调用队列中跳过的的系统调用, 如果找到匹配, 从队列中移除并返回到对应的处理程序.

如果都没找到, 有可能有额外的系统调用在日志模式中执行但却没有在这次执行. 如果流程产生了匹配, 日志中应当被跳过的系统调用将添加到buf_skipped中, 匹配将返回到对应的处理程序.

如果没有产生匹配, 则该系统调用没有在日志模式中被调用, 添加到buf_extra并传递给操作系统.

我们的算法使用两个配置参数, L和M. L用于检测两次执行的行为偏差. 更准确地说, 在回放中任何时间, 在日志追踪中被跳过或是添加的系统调用数达到了L, 算法将判断这次程序的执行不同与日志模式. 为了避免短时, 局部不同的堆积, 我们移除在M次执行匹配算法后被插入buf_skipped和buf_extra的系统调用.

## 实施

我们的方法需要一个能够记录并重放虚拟机内外部系统调用的登录基础部件. 这里我们会描述我们实施这一基础部件的方案和一些需要解决的有趣的技术问题.

### 记录和回放部件

我们的记录和回放部件有两部分: 用户程序和内核驱动. 我们的用户程序负责加载启动驱动并通过发出特定的IO控制码去控制驱动. 它还要启动要分析的程序, 与驱动通讯进程ID, 和接收和存储记录阶段产生的数据.

驱动是系统的核心部件. 负责捕获所有系统调用, 记录和回放所有在监视程序与内核间交换的数据. 这通过与系统服务描述符表(SSDT)链接实现. SSDT中的每条入口包含着系统调用的入口点, 当程序调用这样一个调用时, SSDT查询负责该服务的函数地址.

当一个驱动加载完毕, 每条包含系统调用地址的入口被重写指向我们自己的处理函数地址. 然而 因为还是需要能够调用原生方法, 将系统调用的原始地址保存在备份表中(当内核模块移除时恢复).

逐一手动写入283条包装了Windows XP系统调用的处理程序是非常不切实际的. 此外, 函数参数常常包含了如结构指针(有时其递归包含对其他结构的引用)这样的复杂数据, 这使手动方法更加复杂. 为了解决这些问题, 我们实现了一个自动生成处理函数代码的工具. 这个生成工具接收系统调用声明和参数(特别是数据结构)定义作为输入. 我们从Windows研究内核中提取信息. 然后对于每个系统调用, 我们的工具生成两份代码, 一个被使用于记录模式另一个是回放模式.

在记录模式, 我们所有系统调用处理程序有同样的目的:　作为用户空间程序和原始系统调用处理程序间的代理, 记录所有程序与内核的交换数据. 通过在系统调用前后递归记录下参数内容来实现.内核驱动有个缓冲区被处理函数用来临时存储所有系统调用参数值. 出于性能考虑, 驱动不将缓冲内容写入文件. 而是一定间隔后用户空间程序从驱动缓冲复制到用户空间, 最后存储为二进制日志文件. 

在回放模式, 驱动有两个主要任务: 提供给程序和参考系统下一样的输入数据, 和分析程序行为, 检测和期待行为的差异.

就如在章节3中解释的那样, 不可能盲目的截获所有系统调用并回放它们的参数. 一些函数在内核中有着重要的副作用(比如程序请求分配新内存), 因此它们必须转发给原始处理程序进行处理. 另一些系统调用(当程序从注册表中读键值)通过替换掉所有的输出参数以及返回从日志文件中提取的对应值可以被安全的回放.处理程序在前者转发系统调用, 在后者回放.

最后, 在回放过程中驱动的最后一个任务由监视程序可能的差异组成, 使用在章节3中提到的弹性匹配算法完成.

本节的剩余部分, 我们将讲述我们的记录与回放设备在实践中的各方面.

### 处理一致性

在Windows中, 句柄是一种不透明整型, 被抽象出来以提供统一接口给内核对象. 根据使用时上下文, 句柄可以指向文件, 注册表键, 进程, 计时器, 事件, 通信端口等. 由于我们只重放部分系统调用而让操作系统执行其他的, 在回放模式, 程序由两种处理程序: 实时句柄, 其指向内核中存在的对象; 回放句柄, 由我们的回放处理程序从日志中接受并传递给程序. 例如, 如果程序试图打开文件, 我们截获打开文件的系统调用并回放所有对应的输出参数, 包括文件句柄等, 它被程序使用来进行对该文件的其他操作. 然而, 由于打开文件的系统调用被我们的驱动截获而不是内核, 我们返回的句柄并不能反映内核内存的任何实际对象.

这个问题的产生原因是某些系统调用封装(例如对于关闭操作的封装)可以操作两种处理. 为了正确执行, 这些系统调用需要分辨它们应该传递一个实时句柄(不能回放)还是回放句柄(不会被转发给系统). 因此, 我们的系统维护一份包含所有回放句柄的列表. 然后当系统调用封装接受到不在列表中的句柄时, 就将调用简单的转发给操作系统.

### 网络

Windows并没有专门的网络操作系统调用. 相反, 大多数函数通过NtDeviceIOControlFile -- 一个用于用户空间程序与设备驱动通信的通用系统调用, 使用未记录的接口进行导出.

NtDeviceIOControlFile有两个不透明参数, InputBuffer 和 OutputBuffer, 其被用于程序与驱动交换信息. 具体的数据和参数格式取决于程序的功能需求. 为了实现我们的网络处理程序, 我们需要进行逆向工程, 以了解那些最常用的网络操作的格式及语义. 举个实例, 当RECV函数被调用, 它需要输入流的第一个单词是一个指向处理内存数据结构的指针, 这块内存包含一个保存接收到的网络套接字字节数组指针.

在回返模式中, 驱动分析NtDeviceIOControlFile的参数. 如果NtDeviceIOControlFile指定的函数是我们工具所支持的函数之一, 则对应的处理程序将与日志文件中的值一同调用(因此, 需要重放网络操作). 否则系统调用将被简单的重定向至操作系统. 这避免了破坏那些使用了NtDeviceIOControlFile接口但是还没有进行逆向工程的服务.我们已经实现了对TCP套接字的支持. 用相似的方式也能实现对UDP系统的支持.

### 延迟的结果

另一个问题是, 网络系统调用常常在结果可用之前就返回了(在请求的数据准备发送给用户空间程序之前). 这种现象称为延迟的结果, 在文件系统相关的系统调用时也普遍发生. 更准确的说, 任何时候系统调用返回一个STATUS PENDING 结果, 则意味着请求动作成功启动但是对于这个程序结果不可用. 之后, 程序线程必须等待至操作完成. 该操作完成要调用指定的事件处理程序上的NtWaitForSingleObject(或类似的).

要记录延迟的结果, 我们遵循两步策略. 首先, 当一个系统调用处理程序由部分输出参数被延迟, 它把每个延迟的参数的储存器位置保存在内部延迟参数表中(DPL). 第二步发生在NtWaitForSingleObject系统调用处理程序中. 这个处理程序转发调用到系统. 如果结果是STATUS_SUCCESS, 意味着延迟的数据现在可用. 之后保存在DPL中的参数值可被接收, 它们被插入到日志中正确的位置.

要回放延迟的结果很简单. 事实上, 当处理程序需要用延迟的结果回放系统调用时, 它立即复制所有数据(包括延迟的参数值)到输出参数并返回给程序. 然而, 为了防止改变程序的行为, 它也会回放STATUS PENDING返回码.  这让程序认为某些参数确实延迟了(尽管它们已经被复制到了程序里). 因此, 该程序用NtWaitSingleObjection系统调用同步运行, 沿着与参考系统下同样的执行路线.

### 线程管理

管理多线程程序带来了额外挑战. 特别是记录模式, 我们需要确保所有测试下的线程被正确识别, 以便分辨不同线程所调用的系统调用. 为了做到这一点, 我们的NtCreateThread系统调用处理程序为每一个新线程初始化一份日志. 然后它简单的转发系统调用给系统, 再记录下分配给新线程的ID. 利用线程ID, 我们为每一个线程与日志建立起独一无二的关联. 其他调用处理程序可以取得当前线程ID, 并将信息储存在对应的日志文件中. 日志中也存储了线程调用系统调用的相对顺序.

在回放模式中, NtCreateThread系统调用处理程序让系统处理调用并根据调用顺序关联新建的线程(它们的线程ID)到对应的日志文件. 我们的系统调用, 和日志模式做的事情类似, 使用线程ID获取正确的日志文件并回放输入. 这些线程间不存在竞争条件, 要正确回放多个线程这已经足够了. 虽然我们尚未发现依赖竞争条件的恶意软件样本, 但要处理这样的情况也是可能的. 例如强制以同样的顺序调度多个线程.

### 内存映射文件

现代操作系统使用内存映射技术将全部或部分文件内容映射到程序地址空间中的内存区域. 当一个文件被映射到内存中, 程序无需调用额外的系统调用便能自由读取与修改内容. 但这也会妨碍我们的系统加载与重放这些操作. 一种基于中断的技术在修改发生时可以截获对内存映射区域的访问并存储内容.然而我们发现在我们的情况中, 最常见的内存映射用途可以通过转发内存映射给系统来安全地处理.

在Windows中, 内存映射经常被程序加载器用来加载动态链接库(DLL)进内存. 动态链接库应该被看作程序的输入, 所以在原则上应该被记录及回放. 然而, 在参考系统与分析系统上保留同样的动态链接库并让程序自由地从硬盘上加载它们要高效的多. 因此, 当内核模块接受到打开或映射系统库的请求时, 它就停用对系统调用的回放并转发请求给操作系统.

第二个内存映射的常见用处是我们观察到在恶意样本中被用来创建可执行程序并在稍后运行. 要解决这个问题, 我们分析了在参考系统中生成的日志文件. 每次我们发现一个文件被程序创建并进行内存映射时, 我们从日志中删除负责打开和创建文件的系统调用. 然后, 在回放阶段, 匹配算法将无法在日志中找到被删去的对应的系统调用. 因此, 这条系统调用被加到额外系统调用的队列中, 并转发给操作系统. 结果是内存映射文件句柄由操作系统生成, 其他在句柄上进行操作的系统调用也不会被系统重放. 实际效果是程序会在回放模式下创建并操作它.

### 目前的局限

在微软Windows下实现一个正确记录并回放系统调用的系统是个十分复杂的任务. 在很多情况下, 我们不得不对一些内部的没有文档参考的Windows数据结构和行为进行逆向工程.

当前的原型支持很大的一个功能集合而且可以用来分析真正的程序与恶意样本. 然而, 和任何其他原型一样, 它还是存在局限, 我们总结为一下几点:

 - 多进程: 当前的原型不支持多进程程序. 在实际中, 如果多个进程不互相通信, 我们还是可以让我们的系统一次分析一条进程.
 - 随机数: 对于一个依靠随机数进行不定向选择的程序来说, 需要重放参考系统下生成的随机数. 然而Windows随机数生成器是在用户模式实现的(因此对于我们的内核驱动是不可访问的), 它的熵值在内核里. 当前我们已经记录和回放了大部分源, 除了KSecDD设备驱动. 通过记录和回放这个驱动生成的数据, 我们就能够回放随机数.
 - 内部进程通信和异步调用: 我们的原型不会回放任何本地过程调用(LPC)通信. 所有相关的系统调用都转发给操作系统, 这有导致程序执行偏差的风险.
 - 复杂内存映射场景: 就如我们上一节解释的那样, 我们对于内存映射的支持还不完善, 也还不支持如将映射区域作为不同进程间的共享空间的用法.

前面的一些局限可能看起来很严重. 但事实上, 对于攻击者想要利用这些局限去妨碍我们的记录/回放设备正常工作也是不可能的. 这些攻击智慧导致我们的系统检测到差异并发出警报. 我们所遭受的后果无非是进行细粒度分析的性能损耗.

恶意程序通过推迟检查分析环境来逃过我们的系统是有可能的. 这类似于恶意软件在进行恶意行为前推迟一段时间以便逃过分析环境的检查. 不幸的是对于这种问题还没有简单的解决方法, 除非运行分析环境更长的时间.

此外, 通过将有害行为分解为数个非常短(而且距离很远)的系统调用序列可能可以逃避我们的灵活性匹配算法, 局部差异可能在我们的检测机制眼皮下飞走. 尽管这在理论上可行, 我们尚未研究对于实现这样的恶意软件有多复杂.

最后, 另一个局限是那些能够访问内核结构的恶意软件能够检测到我们的驱动组件并采取措施来逃避检测. 但我们不认为这是个严重的问题. 首先, 先前对于恶意软件趋势的研究表明不到3.34%的样本安装了内核驱动. 其次, 这类恶意软件很可能在获取系统权限前检查环境(因此在获取权限前会被我们的工具检测到), 否则, 恶意软件作者可能会暴露恶意功能给分析环境. 最后, 我们可以使用透明解决方案来完善记录/回放系统. 事实上, 我们相信我们可以在快速粗略模式下运行Ether, 然而我们还没有探索这种方法的可行性, 因为在我们开始这个项目前Ether还不可用.